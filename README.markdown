# Quaternionic experiment


## Introduction

Lie algebras are at the heart of geometry and analysis. For example, they
describe local symmetry in differential equations. Moreover, there is a complete
classification of Lie algebras over the fields of real and complex numbers. The
classification reduces any finite dimensional Lie algebra into a sum of a
commutative part and a finite sum of simple Lie algebras, where the simple
components can only be drawn from the classification. This is very similar to
the way that a natural number can be decomposed into a unique product of prime
numbers.

Examples of Lie algebras are usually presented as sub-algebras of matrix
algebras, usually over the complex numbers, but also over the reals and the
quaternions. From any associative algebra there is an associated Lie algebra,
derived as the commutator, $[x,y] = xy -yx $. 

The algebra of quaternions $\H$ is a naturally occurring associative algebra of
the reals that is not a matrix algebra. In the sense that the Brauer group of
the reals is generated by $\H$, it is the only associative algebra that is not a
matrix algebra. In particular the Lie algebra associated in this way to the
algebra of quaternions is $so(3)$, which is the simplest simple Lie algebra, and
generates rotations in three dimensions.

The purpose of this experiment is to calculate the complete Lie algebra
decomposition of tensor powers of the quaternions. The decomposition follows
from the classification of real Lie algebras, and relies on the various
algorithms described by ... 

## Methods

### Using Haskell

A secondary purpose of this experiment is to use the Haskell programming
language to ensure that the program is correct, while allowing the compiled code
to run as quick as compiled C code. The goals can be stated as:

1. Correct and concise expression of algorithms that is evidently correct
2. Fast compiled execution, that can produce the outputs that we want.

These two objectives normally work directly against each other. In this
experiment we will show that Haskell's modern type system can faithfully express
the mathematical structures we need, but gets out of the way when we compile the
code.

The code is split between a general purpose library file and a script that
generates output.





